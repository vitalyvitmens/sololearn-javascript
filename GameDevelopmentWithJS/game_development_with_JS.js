//TODO: Game Development with JS (Разработка игр с JS)
// Добро пожаловать на наш курс по разработке игр! В ходе этого курса мы научимся разрабатывать игры в Интернете. Мы начнем с основ HTML 5, CSS и JavaScript, а также покажем, как создавать настоящие веб-игры с нуля!

//TODO: Introduction (
// Введение:
// Добро пожаловать на наш курс по разработке игр!!!
// В ходе этого курса мы научимся разрабатывать игры в Интернете.
// Мы будем использовать базовые веб-технологии: HTML 5, CSS и JavaScript.
// Мы начнем с основ HTML 5, CSS и JavaScript, а также покажем, как создавать настоящие веб-игры с нуля!

//TODO: JavaScript (JavaScript)
// JavaScript — это язык программирования для Интернета. Его можно использовать для создания интерактивных элементов, создания раскрывающихся меню, обработки событий нажатия кнопок и многого другого!
// В нашем курсе мы будем использовать JavaScript для рисования фигур, графики, а также для создания анимации.

//TODO: Benefits of HTML (Преимущества HTML)
// Одним из самых больших преимуществ использования HTML/CSS/JavaScript является то, что он может работать на любом устройстве без необходимости в каком-либо дополнительном программном обеспечении! Это возможно, потому что он работает в браузере, как простой веб-сайт.
// Большинство современных браузеров поддерживают тот функционал, который мы будем использовать, благодаря чему наши игры запускаются даже на мобильных устройствах!

//TODO: Introduction (
// Введение
// Вот некоторые вещи, которые мы изучим в этом курсе:
// - HTML
// - CSS
// - JavaScript basics (Основы JavaScript)
// - Drawing on the web (Рисование в Интернете)
// - Animations (Анимации)
// - Game Loops (Игровые циклы)
// - Collision Detection (Обнаружение столкновений)
// - и многое другое!
// Если вы чувствуете, что вам нужна дополнительная информация, вы всегда можете обратиться к нашим учебникам по HTML, CSS и JavaScript, которые охватывают основные теги, синтаксис и концепции веб-разработки.

//TODO: HTML (HTML)
// Начнем с HTML.
// HTML расшифровывается как язык гипертекстовой разметки . _ _ _ Язык разметки использует теги для идентификации содержимого.
{
  /* <p> — это тег, используемый для создания абзаца текста.
Вот пример тега HTML: */
}
{
  /* <p> I'm a paragraph </p> */
}

//TODO: Tags (Теги)
// Большинство тегов имеют открывающий и закрывающий теги, между которыми размещается содержимое.
// Например, тег абзаца <p> должен иметь закрывающий тег </p> .
// Закрывающий тег создается с помощью косой черты / .
{
  /* <p> I'm a paragraph </p> */
}

//TODO: Basic HTML Document (Базовый HTML-документ)
// В HTML есть много разных тегов, которые служат своей цели.
// Базовый HTML-документ в Интернете имеет следующую структуру:
// Тег <html> определяет страницу, а тег <body> определяет основное содержимое HTML-документа и содержит все элементы страницы, такие как абзацы, таблицы, списки и т.д.
{
  /* <html>
   <body>
   </body>
</html> */
}

//TODO: HTML Headings (HTML-заголовки)
// Теперь давайте посмотрим на некоторые из основных элементов, которые мы можем создать.
// Заголовки используются для создания заголовков и подзаголовков на странице.
// HTML включает шесть уровней заголовков, ранжированных по степени важности.
// Это <h1>, <h2>, <h3>, <h4>, <h5> и <h6>. Следующий код определяет все заголовки:
{
  /* <html>
    <head>
        <title>first page</title>
    </head>
    <body>
        <h1>This is heading 1</h1>
        <h2>This is heading 2</h2>
        <h3>This is heading 3</h3>
        <h4>This is heading 4</h4>
        <h5>This is heading 5</h5>
        <h6>This is heading 6</h6>
    </body>
</html> */
}

//TODO: Paragraphs (Параграфы, обзацы, пункты)
// Как мы уже видели, абзацы создаются с помощью тега <p> . На нашей странице
// может быть несколько тегов <p>:
{
  /* <h1>My Game</h1>
<p>This is fun</p>
<p>This is another text</p> */
}

//TODO: Line Break (Разрыв строки)
// Некоторые элементы HTML не имеют закрывающего тега. Например, тег <br /> используется для добавления разрыва строки:
// Приведенный ниже код создает абзац текста с разрывом строки.
// Как видите, теги HTML можно включать в другие теги для форматирования содержимого.
{
  /* <p>
Name: Player 1 <br />
Points: 42
</p> */
}

//TODO: Practice: HTML Basics (Практика: основы HTML)
// Давайте вспомним некоторые основные концепции HTML, которые вы можете применить к своему игровому проекту.
// 1. Заголовки используются для создания заголовков и подзаголовков на странице.
// HTML включает шесть уровней заголовков, ранжированных по степени важности.
// Это <h1>, <h2>, <h3>, <h4>, <h5> и <h6>.
// 2. Абзацы создаются с помощью тега <p>.
{
  /* <div class="box">
  some text
</div> */
}

//TODO: Практика: Welcome to Code Repo! (Добро пожаловать в репозиторий кода!)
// В этом проекте мы создадим игру Jumper с нуля.
// Мы начнем с базовой веб-структуры и перейдем к более сложной анимации и обработке событий по мере прохождения уроков!
// Просмотрите каждую задачу, напишите свой код, зафиксируйте его, чтобы сохранить прогресс, и продолжайте развивать проект на каждом этапе.
// Это будет весело, так что давайте начнем! Давайте начнем с базового HTML. Задания: 1. Добавить заголовок с текстом «My Jumper Game». 2. Добавьте абзац под заголовком, который гласит: «Веселая игра, похожая на птичку». Подсказка : добавьте заголовок и абзац, используя соответствующие теги, например:
{
  /* <h1>My Jumper Game</h1>
<p>A fun flappy-bird like game.</p> */
}

//TODO: HTML Attributes (HTML-атрибуты)
// Атрибуты предоставляют дополнительную информацию об элементе или теге, а также изменяют их. Большинство атрибутов имеют значение; значение изменяет атрибут.
// В этом примере значение «center» указывает, что содержимое внутри элемента p должно быть выровнено по центру:
// Атрибуты всегда указываются в начальном теге и появляются в парах name="value".
{
  /* <p align="center">
    This text is aligned to center
</p>
<p align="right">
    This text is aligned to right
</p> */
}

//TODO: Attribute Measurements (Измерения атрибутов)
// Тег <hr /> используется для создания простой горизонтальной линии.
// Например, мы можем изменить горизонтальную линию так, чтобы она имела ширину 50 пикселей. Это можно сделать с помощью атрибута ширины:
// Ширина элемента также может быть определена в процентах:
// Строка займет 50% ширины страницы.
{
  // <hr width="50px" />
  // <hr width="50%" />
}

//TODO: Images (Изображения, картинки)
// Изображения добавляются с помощью тега <img />.
// Атрибут src используется для определения URL-адреса изображения.
// Вот пример:
{
  //  <img src="http://www.sololearn.com/images/tree.jpg"
  //  height="150px" width="150px" />
}

//TODO: Image Resizing (Изменение размера изображения)
// Чтобы определить размер изображения, используйте атрибуты ширины и высоты . Значение может быть указано в пикселях или в процентах:
// Как видите, тег <img /> не нуждается в закрывающем теге.
//   <img src="http://www.sololearn.com/images/tree.jpg" height="150px" width="150px" />
// <br />
// <img src="http://www.sololearn.com/images/tree.jpg" height="50%" width="50%" />

//TODO: Summary (Резюме)
// HTML поддерживает множество других тегов, таких как кнопки, текстовые поля и т.д.
// Все они имеют одинаковую структуру: у них есть открывающий и закрывающий тег, и их можно изменять с помощью атрибутов. Вот почему понимание логики важнее, чем запоминание всех названий тегов, так как вы всегда можете поискать и найти нужный тег.
// Мы не будем рассматривать все теги, доступные в HTML. Вместо этого мы будем объяснять их по мере того, как сталкиваемся с соответствующим элементом в наших примерах и играх.

//TODO: Practice: Attributes (Практика: атрибуты)
// Пришло время пересмотреть некоторые вещи и попрактиковаться!
// Атрибуты предоставляют дополнительную информацию об элементе или теге, а также изменяют их. Большинство атрибутов имеют значение; значение изменяет атрибут. Например, align="center" перемещает содержимое в центр.
{
  /* <div class="box">
  some text
</div> */
}

//TODO: Практика: Attributes (Практика: атрибуты)
// Давайте добавим немного выравнивания к нашему заголовку и абзацу!
// Задача: Выровнять заголовок и абзац по центру страницы.
// Подсказка: используйте атрибут align="center" в начальных тегах, например:
{
  /* <h1 align"center">My Jumper Game</h1>
<p align"center">A fun flappy-bird like game.</p> */
}

{
  /* <h1>My Jumper Game</h1>
<p>A fun flappy-bird like game.</p> */
}

//TODO: CSS (Cascading Style Sheets)
// CSS означает каскадные таблицы стилей.
// CSS и HTML работают рука об руку:
// - HTML определяет структуру страницы.
// - CSS определяет стили.
// Мы научимся применять различные стили к элементам HTML!

// TODO: Inline CSS (Встроенный CSS)
// Использование встроенного стиля — один из способов вставки таблицы стилей.
// При использовании встроенного стиля уникальный стиль применяется к одному элементу. Чтобы использовать встроенный стиль, добавьте атрибут стиля к соответствующему тегу.
// В приведенном ниже примере показано, как создать абзац с серым фоном и белым текстом:
// Атрибут стиля может содержать несколько свойств CSS.
{
  //   <p style="color:white; background-color:gray;">
  //     This is an example of inline styling.
  // </p>
}

// TODO: CSS Styles (Стили CSS)
// Давайте снова посмотрим на код:
// Стили CSS внутри атрибута стиля имеют следующий формат:
// Каждое определение свойства заканчивается точкой с запятой.
{
  //   <p style="color:white; background-color:gray;">
  //     This is an example of inline styling.
  // </p>
}
{
  // property:value;
}

// TODO: CSS Properties (CSS-свойства)
// CSS поддерживает множество свойств, таких как: цвет, ширина, высота, граница и т.д. Например, давайте создадим абзац с заданной шириной и цветом фона:
// Как и в случае с HTML, в ходе нашего курса мы узнаем о других свойствах CSS.
{
  /* <p style="width:50px;background-color:red">
This is some text
</p> */
}

// TODO: External CSS (Внешний CSS)
// Другой способ определить CSS для HTML-страницы — создать отдельный файл CSS.
// Таким образом, все стили определяются в отдельном файле, который связан с HTML.
// Чтобы указать стиль для определенного элемента HTML, нам нужно его выбрать.
// Для этого нам нужно предоставить элементу HTML атрибут id. Например:
// Мы дали абзацу идентификатор, который можно использовать для его выбора в CSS.
// Значение идентификатора может быть любым.
{
  //   <p id="name">
  // Player One
  // </p>
}

// TODO: External CSS (Внешний CSS)
// Чтобы выбрать элемент с определенным идентификатором, используйте символ решетки, а затем укажите идентификатор элемента:
// Обратите внимание, что мы используем одно и то же свойство: значение; синтаксис при определении стилей CSS. Единственным отличием являются фигурные скобки, используемые для заключения стиля.
{
  /* <p id="name">Player One</p> */
}
// #name {
//   color: white;
//   background-color: blue;
// }

// TODO: External CSS (Внешний CSS)
// Селекторы классов работают аналогичным образом. Основное отличие состоит в том, что идентификаторы могут применяться только один раз на странице, а классы могут использоваться на странице столько раз, сколько необходимо. Например, допустим, нам нужно применить один и тот же стиль к двум абзацам, содержащим имена игроков:
// Таким образом, мы можем создать один стиль и применить его к нескольким элементам.
// Обратите внимание, что нам нужно использовать точку перед именем класса вместо хэша при использовании идентификатора.
{
  /* <p class="name">
  Player One
</p>
<hr />
<p class="name">
  Player Two
</p> */
}
// .name {
//   color: white;
//   background-color: blue;
// }

// TODO: Practice: CSS Basics (Практика: основы CSS)
// Давайте повторим некоторые элементы CSS и реализуем их в качестве следующего шага в нашем проекте. Вы можете связать стиль CSS с помощью тегов HTML , атрибутов id и имен классов. Например, приведенный выше код установит цвет и цвет фона заголовка:
{
  // <h1>My Game</h1>
}

//TODO: Практика: Adding CSS (Добавление CSS)
// Давайте сделаем нашу страницу красивее, добавив несколько цветов с помощью CSS! Задача: 1. Добавьте цвет фона на страницу: установите цвет #c3c3c3 . 2. Измените цвет заголовка на #4c6ebb . Подсказка: чтобы изменить цвет фона страницы, используйте тело в CSS, например:
// body {
//   background-color:#c3c3c3;
// }
// Точно так же установите цвет для заголовка:
{
  // h1 {
  //   color: #4c6ebb;
  // }
}

//TODO: JavaScript (JavaScript)
// Теперь, когда мы знаем, как создавать HTML-элементы и стилизовать их с помощью CSS, давайте познакомимся с JavaScript. Чтобы увидеть результаты наших примеров, нам нужно сгенерировать некоторый вывод. Для этого мы будем использовать функцию console.log(). Например:
// console.log('Hello!')
// Это выведет текст "Hello!" в консоль.
// Консоль является частью веб-браузера и позволяет вам регистрировать сообщения, запускать код JavaScript и просматривать ошибки и предупреждения.

//TODO: Text (Текст)
// Чтобы использовать текст в JavaScript, нам нужно заключить его в кавычки:
// Текст внутри кавычек называется строкой.
// Обратите внимание, что каждое выражение заканчивается точкой с запятой.

//TODO: Numbers (Числа)
// При работе с числами кавычки не нужны.
// В программировании целые числа называются целыми, а десятичные — числами с плавающей запятой.
// console.log(42)
// console.log(3.14)

//TODO: Variables (Переменные)
// В играх нам обычно нужно хранить какие-то значения и работать с ними во время игры.
// Это делается с помощью переменных, которые являются контейнерами для хранения значений.
// Переменные могут быть объявлены с использованием ключевого слова var:
// points — это имя нашей переменной, а 42 — это значение, которое она содержит.
// var points = 42
// console.log(points)

//TODO: Variables (Переменные)
// Мы можем использовать различные математические операторы с переменными. Для примера создадим две переменные, посчитаем их сумму и выведем результат в консоль.
// Переменные можно переназначать столько раз, сколько вы хотите, чтобы изменить их значение.
// var x = 8
// var y = 54

// console.log(x + y)

//TODO: Operators (Операторы)
// Вот список основных математических операторов с примерами:
// Как и в случае с математикой, вы можете использовать круглые скобки, чтобы определить, какие операции необходимо выполнить в первую очередь.
// См. Рис: Operators.png
// var x = (1 + 2) * 3
// console.log(x)

//TODO: Variables (Переменные)
// Другой способ объявить переменную — использовать ключевое слово let:
// Ключевое слово let является новым для JavaScript и имеет ряд преимуществ по сравнению с var. Например, переменные let нельзя повторно объявить, что упрощает поддержку кода и делает его менее подверженным ошибкам.
// let name = 'Player One'
// console.log(name)

//TODO: Decision Making (Принятие решения)
// Обычно наша программа должна принимать решения на основе некоторых значений.
// Например, останавливать игру, когда здоровье ниже 1, или повышать уровень на основе очков. Мы используем if, чтобы указать блок кода, который мы хотим выполнить, если заданное условие истинно.
// Операторы будут выполняться только в том случае, если заданное условие истинно.
// if (condition) {
//   statements
// }

//TODO: Decision Making (Принятие решения)
// Код сравнивает значение переменной работоспособности и выводит сообщение, если оно меньше 1.
// Если условие не истинно, операторы if не будут выполняться.
// let health = 0

// if (health < 1) {
//   console.log('Game Over')
// }

//TODO: Comparison Operators (Операторы сравнения)
// Ознакомьтесь с этой таблицей, чтобы увидеть разбивку операторов сравнения, которые вы можете использовать:
// См. Рис: ComparisonOperators.png

//TODO: Decision Making (Принятие решения)
// Мы можем использовать оператор else, чтобы указать блок кода, который будет выполняться, если условие ложно. Как это:
// В каждом блоке условий if может быть только один оператор else.
// if (expression) {
//   // executed if condition is true (выполняется, если условие истинно)
// } else {
//   // executed if condition is false (выполняется, если условие ложно)
// }

//TODO: Decision Making (Принятие решения)
// Вот пример, который выводит сообщение на основе значения баллов:
// Вы можете иметь сколько угодно операторов внутри if и else. Только не забудьте заключить их в фигурные скобки.
// let points = 42

// if (points >= 100) {
//   console.log('You Win!')
// } else {
//   console.log('Try Again')
// }

//TODO: Functions (Функции)
// Функция — это блок кода, предназначенный для выполнения определенной задачи.
// Например, в нашей игре могут быть такие функции, как hit(), levelUp(), shoot() и т.д.
// Цель функции состоит в том, чтобы создать ее один раз и вызвать ее несколько раз, когда это необходимо для выполнения определенных задач.

//TODO: Defining a Function (Определение функции)
// Чтобы определить функцию, используйте ключевое слово function, за которым следует имя, за которым следует набор скобок (). Код, который будет выполняться функцией, заключен в фигурные скобки {}.
// function name() {
//   //code to be executed
// }

//TODO: Functions (Функции)
// Давайте создадим функцию под названием « hit », которая выводит простое сообщение. Не забудьте круглые скобки после имени функции.
// function hit() {
//   console.log('Hit!')
// }

//TODO: Calling a Function (Вызов функции)
// После определения нашей функции мы можем вызывать ее в нашей программе столько раз, сколько захотим.
// Чтобы вызвать функцию, начните с имени функции, а затем заключите его в круглые скобки. Давайте вызовем нашу функцию hit() дважды:
// function hit() {
//   console.log('Hit!')
// }

// hit()
// hit()

//TODO: Parameters (Параметры)
// Функции могут иметь параметры, которые они могут использовать в своем коде.
// Параметры определяются в круглых скобках и могут использоваться как переменные в функции. Например, давайте добавим параметр мощности в нашу функцию hit():
// Обратите внимание, что мы использовали оператор + с текстом: это складывает два текста вместе и называется конкатенацией.
// function hit(power) {
//   console.log('Hit with ' + power)
// }

//TODO: Parameters (Параметры)
// Теперь при вызове функции нам нужно передать ей значение параметра мощности внутри скобок.
// Таким образом, мы можем вызывать нашу функцию с разными параметрами и генерировать на их основе разные результаты.
// Функции могут принимать несколько параметров. Для этого нам просто нужно разделить их запятыми, например: удар(сила, оружие)
// function hit(power, weapon) {
//   console.log('Hit with ' + power, weapon)
// }

// hit(42, 'shotgun')
// hit(8, 'an automatic weapon')

//TODO: Functions (Функции)
// JavaScript имеет несколько встроенных полезных функций. Например, функция alert() используется для создания окна сообщения.
// Мы рассмотрим некоторые другие функции в следующих уроках.
// alert('Game Over')

// function test(a, b) {
//   if (a > b) {
//     return a * b
//   } else {
//     return b / a
//   }
// }
// alert(test(5, 15))
// console.log(test(5, 15))

//TODO: Events (События)
// Функции обычно вызываются, когда происходит какое-либо событие, например, нажатие кнопки или клавиши клавиатуры. Допустим, у нас есть кнопка в нашем HTML и мы хотим вызвать нашу функцию, когда кнопка нажата. Как мы это делаем? Вот наша кнопка в HTML:
{
  /* <button id="myButton">
  Click me
</button> */
}

//TODO: Events (События)
// Чтобы обработать событие нажатия кнопки в JavaScript, нам сначала нужно получить ссылку на нее, используя ее идентификатор:
// Функция document.getElementById() позволяет вам выбрать элемент HTML, используя его атрибут id.
// Теперь btn — это переменная, которая ссылается на кнопку.
// let btn = document.getElementById('myButton')
// alert('JavaScript подключен!')

//TODO: Events (События)
// Теперь, когда у нас есть кнопка в JavaScript, мы можем установить для события onclick желаемую функцию:
// Это вызовет функцию hello(), когда пользователь нажмет кнопку.
// Обратите внимание, что скобки в этом случае не нужны.
// function hello() {
//   alert('Hello')
// }
// window.onload = function () {
//   let btn = document.getElementById('myButton')
//   btn.onclick = hello
// }

//TODO: Events (События)
// Вот список общих событий:
// См. Рис: Picture/Events.png

//TODO: Events (События)
// Еще один важный шаг — убедиться, что документ загрузился, прежде чем использовать ссылку на элемент в JavaScript.
// Это можно сделать с помощью события onload окна:
// Обработчик события должен быть функцией, поэтому используется ключевое слово function.
// Обычной практикой является использование события window.onload для выполнения JavaScript.
// function hello() {
//   alert('Hello')
// }
// window.onload = function () {
//   let btn = document.getElementById('myButton')
//   btn.onclick = hello
// }

//TODO: Events (События)
// Давайте воспользуемся полученными знаниями для создания очень простой программы, похожей на игру. Мы объявим переменную здоровья и инициализируем ее значением 100. Каждый раз, когда нажимается кнопка Hit, значение здоровья будет делиться пополам и выводиться на консоль. Когда здоровье достигнет 1, мы предупредим «Игра окончена». Мы уже видели HTML-код кнопки, поэтому давайте перейдем к JavaScript:
// Как только страница загружена, мы берем ссылку на кнопку и вызываем функцию hit() при ее нажатии.
// window.onload = function () {
//   let btn = document.getElementById('myButton')
//   btn.onclick = hit
// }

// let health = 100

//TODO: Events (События)
// Пришло время сделать функцию hit():
// Каждый раз, когда вызывается функция hit(), она обновляет значение переменной здоровья, проверяет, меньше ли оно 1, и выводит соответствующие сообщения.
// window.onload = function () {
//   let btn = document.getElementById('myButton')
//   btn.onclick = hit
// }

// let health = 100

// function hit() {
//   health = health / 2
//   if (health <= 1) {
//     alert('Game Over!')
//   } else {
//     console.log(health)
//   }
// }

//TODO: Practice: Handling Events (Практика: обработка событий)
// Пришло время продолжить наш проект! Но сначала давайте рассмотрим обработку событий.
// 1. Кнопка в HTML создается с помощью тега <button>.
// 2. Чтобы обработать событие нажатия кнопки в JavaScript, нам сначала нужно получить ссылку на нее с помощью функции document.getElementById(),
// а затем установить ее событие onclick.
// 3. Нам нужно убедиться, что документ загрузился, прежде чем брать ссылку на элемент в JavaScript. Это можно сделать с помощью onload event of the window. Например:
// function hello() {
//   alert('Hello')
// }
// window.onload = function () {
//   let btn = document.getElementById('myButton')
//   btn.onclick = hello
// }

//TODO: Practice: Handling Events (Практика: обработка событий)
// Время добавить JavaScript!
// Задачи:
// 1. Добавить в HTML кнопку с текстом Jump (Перейти).
// 2. Создайте переменную count для хранения количества нажатий кнопки.
// 3. Обработайте событие click (щелчка) для кнопки и увеличивайте переменную count при каждом нажатии.
// Подсказки:
// 1. Дайте кнопке идентификатор, чтобы вы могли ссылаться на нее с помощью JavaScript с помощью функции document.getElementById().
// 2. Используйте событие window.onload, чтобы получить ссылку на вашу кнопку.
// 3. Чтобы обработать событие click (щелчка), используйте обработчик нажатия кнопки.
// 4. Инициализируйте счет
// переменную на 0 и увеличивайте ее при нажатии кнопки, например, count += 1 . Пример HTML-кода
{
  /* <button id="jump">Jump</button>  */
}
// Пример кода Java-скрипта
// Вы должны видеть увеличение количества кликов в диалоговом окне каждый раз, когда нажимается кнопка перехода.
// window.onload = function () {
//   let btn = document.getElementById('jump')
//   let count = 0

//   btn.onclick = function () {
//     count += 1
//     alert(count)
//   }
// }

//TODO: HTML5 Canvas (Холст HTML5)
// Мы изучили все необходимые основы,
// так что теперь мы можем начать веселиться и делать игры! Чтобы сделать игру, нам сначала нужно научиться рисовать в сети. Чтобы рисовать фигуры и анимацию для нашей игры, мы будем использовать тег <canvas>. Он стал доступен в HTML5, что позволяет рисовать на нем с помощью чистого JavaScript.
// Холст действует как доска для рисования.

//TODO: HTML5 Canvas (Холст HTML5)
// Начнем с настройки основного холста. Вот:
// Мы дали нашему холсту атрибут id, чтобы мы могли идентифицировать и ссылаться на него из JavaScript. Мы узнаем, как это сделать позже.
{
  /* <canvas id="canvas" width="600" height="400">
  Your browser does not support the HTML5 canvas tag.
</canvas>  */
}

//TODO: HTML5 Canvas (Холст HTML5)
// Давайте снова посмотрим на код:
// Мы установили ширину и высоту нашего холста, определяя размер холста по умолчанию.
// Текст между тегами холста используется для определения резервного текста на случай, если пользователь использует старый браузер, не поддерживающий HTML5.
{
  /* <canvas id="canvas" width="600" height="400">
Your browser does not support the HTML5 canvas tag.
</canvas>  */
}

//TODO: HTML5 Canvas (Холст HTML5)
// Мы устанавливаем ширину и высоту нашего холста. Но как это будет работать на разных размерах экрана? Мы можем масштабировать наш холст, чтобы он соответствовал размеру экрана, используя CSS:
// Это заставит наш холст масштабироваться на всю ширину экрана.
// Запустите код, чтобы увидеть результат.
{
  /* <canvas id="canvas" width="600" height="400">
  Your browser does not support the HTML5 canvas tag.
</canvas> */
}

//TODO: HTML5 Canvas (Холст HTML5)
// Но как нам рисовать на холсте, если он масштабируется в зависимости от размера экрана, который может различаться у разных пользователей?
// Рисование на холсте осуществляется с помощью координат. Начальный размер, который мы задаем в теге canvas, определяет его координатное пространство. Это означает, что вы рисуете в пределах исходного установленного размера, а холст автоматически масштабирует рисунки. Верхний левый угол имеет координату (0, 0).
// Все операции рисования будут выполняться в пределах этого координатного пространства, независимо от фактического размера холста.
// См. Рис: HTML5_Canvas.jpg

//TODO: HTML5 Canvas (Холст HTML5)
// Теперь у нас есть пустой холст, который масштабируется до любого размера экрана.
// Но как нам рисовать на нем фигуры? Вот где на помощь приходит JavaScript!
// Нажмите «Продолжить», чтобы научиться рисовать на холсте с помощью JavaScript.

//TODO: HTML5 Canvas (Практика: Холст HTML5)
// Повторение - мать учения! Подведем итог тому, что мы узнали о Canvas, и применим полученные знания на практике.
// 1. Тег <canvas> используется для рисования фигур и анимации. Он имеет атрибуты ширины и высоты, определяющие его размер.
// 2. Мы можем масштабировать наш холст, чтобы он соответствовал размеру экрана, используя CSS.
// 3. Рисование на холсте осуществляется с помощью координат. Например:
{
  /* <canvas id="canvas" width="600" height="400">
  Your browser does not support the HTML5 canvas tag.
</canvas> */
}

//TODO: Practice: Creating a Canvas (Создание холста)
// Создадим холст! Задачи:
// 1. Добавьте на страницу холст размером 600x400.
// 2. Масштабируйте его до ширины 100% с помощью CSS и назначьте ему черный фоновый цвет.
// HTML-код
{
  /* <canvas id="canvas" width="600" height="400">
  Your browser does not support the HTML5 canvas tag.
</canvas>
<br></br>
<button id="jump">Jump</button> */
}
// CSS Code
// canvas {
//     width: 100%;
//     background-color: black;
// }

//TODO: Drawing Shapes (Рисование фигур)
// Пора заняться рисованием! Мы создали наш холст в HTML:
{
  /* <canvas id="canvas" width="600" height="400">
Your browser does not support the HTML5 canvas tag.
</canvas>  */
}
// Далее нам нужно взять ссылку с помощью JavaScript:
// canvas = document.getElementById('canvas')

//TODO: Drawing Shapes (Рисование фигур)
// Чтобы получить доступ к функциям рисования, нам нужно определить контекст 2D-холста.
// Это делается с использованием следующего синтаксиса:
// Контекст холста — это объект со свойствами и функциями, которые можно использовать для рисования внутри элемента холста.
// context = canvas.getContext('2d')

//TODO: Drawing Shapes (Рисование фигур)
// Чтобы убедиться, что холст загружен, прежде чем брать ссылку на него, обычной практикой является использование события onload окна:
// window.onload = function () {
//   var canvas = document.getElementById('canvas')
//   var context = canvas.getContext('2d')
// }

//TODO: Drawing a Line (Рисование линии)
// Теперь, когда у нас есть контекст нашего холста, мы можем начать рисовать!
// Первая фигура, которую мы нарисуем, — прямая линия.
// Для этого мы будем использовать следующие три функции:
// - moveTo ()
// - lineTo ()
// - stroke ().
// Функция moveTo () определяет положение координат на холсте,
// Функция lineTo () определяет координаты конца нашей линии,
// Функция stroke() рисует линию.
// Например:
// Это нарисует линию от точки (50, 100) до точки (400, 200).
// Помните, размер нашего холста 600x400. Это означает, что верхний левый угол имеет координаты (0, 0), а нижний правый угол: (600, 400).
{
  /* <canvas id="canvas" width="600" height="400">
  Your browser does not support the HTML5 canvas tag.
</canvas> */
}
// window.onload = function () {
//   var canvas = document.getElementById('canvas')
//   var context = canvas.getContext('2d')

//   context.moveTo(50, 100)
//   context.lineTo(400, 200)
//   context.stroke()
// }

// TODO: Drawing a Line (Рисование линии)
// Проведем диагональную линию из левого верхнего угла в правый нижний угол.
// Помните, размер холста 600х400.
// Не забудьте про функцию stroke() — она нужна для рисования линии.
// window.onload = function () {
//   var canvas = document.getElementById('canvas')
//   var context = canvas.getContext('2d')

//   context.moveTo(0, 0)
//   context.lineTo(600, 400)
//   context.stroke()
// }
{
  /* <canvas id="canvas" width="600" height="400">
  Your browser does not support the HTML5 canvas tag.
</canvas> */
}

// TODO: Rectangle (Прямоугольник)
// Рисование прямоугольника выполняется с помощью функции rect(), которая имеет следующий синтаксис:
// x и y — начальные координаты — они будут представлять левый верхний угол прямоугольника.
// context.rect(x, y, width, height)

// TODO: Rectangle (Прямоугольник)
// Начертим из точки (50, 50) прямоугольник размером 200x150:
// Как и при рисовании линии, нам нужно вызвать функцию stroke(), чтобы нарисовать прямоугольник.
{
  /* <canvas id="canvas" width="600" height="400">
  Your browser does not support the HTML5 canvas tag.
</canvas> */
}
// window.onload = function () {
//   var canvas = document.getElementById('canvas')
//   var context = canvas.getContext('2d')

//   context.rect(50, 50, 200, 150)
//   context.stroke()
// }

// TODO: Arc (Дуга)
// Чтобы нарисовать круг, нам сначала нужно понять функцию arc() .
// Она имеет следующий синтаксис:
// centerX и centerY представляют центр дуги.
// Радиус - это размер дуги.
// startAngle и endingAngle представляют начало/конец дуги в радианах.
// Последний параметр является необязательным и указывает, должен ли рисунок быть против часовой стрелки или по часовой стрелке.
// Значение по умолчанию — false, что означает, что рисование выполняется по часовой стрелке.
// context.arc(
//   centerX,
//   centerY,
//   radius,
//   startingAngle,
//   endingAngle,
//   counterclockwise
// )

// TODO: Radians (радианы)
// Углы дуги задаются в радианах.
// Радиан — это единица измерения углов, основанная на радиусе окружности.
// Мы можем вычислить углы с помощью радианов и математической константы PI. Например: 180° равно PI * радианы.
// PI — математическая константа, приблизительно равная 3,14159.

// TODO: Drawing an Arc (Рисование дуги)
// Давайте нарисуем дугу с центром в точке (150, 150), начинающуюся с угла 0 и протянувшуюся до угла 180 (который равен PI * радианы):
// Math.PI используется для доступа к значению константы PI.
// Угол 0 находится в положении «3 часа».
// window.onload = function () {
//   var canvas = document.getElementById('canvas')
//   var context = canvas.getContext('2d')

//   context.arc(150, 150, 100, 0, 1 * Math.PI)
//   context.stroke()
// }

// TODO: Drawing a Circle (Рисование круга)
// Теперь, когда мы знаем, как сделать дугу, мы можем сделать полный круг.
// Для этого начальный угол должен быть равен 0, а конечный угол должен быть равен 360°, что составляет 2*PI радиан.
// Круг будет центрирован в центре холста. Поскольку размер холста 600x400, его центр находится в точке (300, 200).
// window.onload = function () {
//   var canvas = document.getElementById('canvas')
//   var context = canvas.getContext('2d')

//   context.arc(300, 200, 100, 0, 2 * Math.PI)
//   // context.moveTo(200, 200)
//   // context.lineTo(400, 200)
//   // context.moveTo(300, 100)
//   // context.lineTo(300, 300)
//   context.stroke()
// }

// TODO: Practice: Rectangles & Circles (Практика: прямоугольники и круги)
// Пришло время продолжить наш проект! Но сначала повторим, как нарисовать круг.
// 1. Функция arc() используется для рисования круга. Он имеет 5 обязательных параметров — координаты, представляющие центр дуги, радиус и начало/конец дуги в радианах.
// 2. Мы можем вычислять углы с помощью радианов и математической константы PI — используйте Math.Pi.
// window.onload = function () {
//   var canvas = document.getElementById('canvas')
//   var context = canvas.getContext('2d')

//   context.arc(300, 200, 100, 0, 2 * Math.PI)
//   context.stroke()
// }

// TODO: Drawing on Canvas (Рисунок на холсте)
// Ты отлично справляешься!
// Давайте нарисуем красный круг на нашем холсте!
// Задачи:
// 1. Возьмите ссылку на холст с помощью JavaScript.
// 2. Добавьте переменные x и y, чтобы определить, где должен быть нарисован круг. Инициализируйте его по центру нижней части холста (x = 300; y = 350).
// 3. Нарисуйте красный круг размером 50.
// Подсказки: рисование круга выполняется с помощью функции дуги контекста.
// window.onload = function () {
//   let btn = document.getElementById('jump')
//   let count = 0
//   var canvas = document.getElementById('canvas')
//   var context = canvas.getContext('2d')
//   var x = 300
//   var y = 350

//   context.arc(x, y, 50, 0, 2 * Math.PI)
//   context.fillStyle = 'red'
//   context.fill()

//   btn.onclick = function () {
//     count += 1
//     alert(count)
//   }
// }

// TODO: Styles (Стили)
// Все фигуры, которые мы нарисовали, имели только тонкий черный контур.
// Это стиль функции stroke() по умолчанию. Мы можем установить цвет и ширину обводки, используя свойства strokeStyle и lineWidth. Например:
// В результате получится прямоугольник с красным контуром 10 пикселей.
// window.onload = function () {
//   var canvas = document.getElementById('canvas')
//   var context = canvas.getContext('2d')

//   context.rect(50, 50, 200, 150)
//   context.lineWidth = 10
//   context.strokeStyle = 'red'
//   context.stroke()
// }

// TODO: Styles (Стили)
// Чтобы добавить цвет заливки к нашим фигурам, нам нужно использовать функцию fillStyle().
// Например, давайте покрасим внутреннюю часть нашего прямоугольника в желтый цвет:
// Подобно рисованию stroke(), нам нужно вызвать функцию fill(), чтобы заполнить фигуру указанным цветом.
// window.onload = function () {
//   var canvas = document.getElementById('canvas')
//   var context = canvas.getContext('2d')

//   context.rect(50, 50, 200, 150)

//   context.fillStyle = 'yellow'
//   context.fill()

//   context.lineWidth = 10
//   context.strokeStyle = 'red'
//   context.stroke()

//   // context.moveTo(50, 50)
//   // context.lineTo(250, 200)
//   // context.strokeStyle = 'black'
//   // context.lineWidth = 1
//   // context.stroke()
// }

// TODO: Styles (Стили)
// Вот полный код для рисования прямоугольника и указания стилей его контура и заливки:
// Рекомендуется использовать функцию fill() перед функцией stroke(), чтобы правильно отобразить обводку.
// window.onload = function () {
//   var canvas = document.getElementById('canvas')
//   var context = canvas.getContext('2d')

//   context.rect(50, 50, 200, 150)

//   context.fillStyle = 'green'
//   context.fill()

//   context.lineWidth = 10
//   context.strokeStyle = 'red'
//   context.stroke()
// }

// TODO: HTML Colors (Цвета HTML)
// В предыдущих примерах мы задавали цвета, используя их имена.
// Функции fillStyle () и strokeStyle() также могут использовать шестнадцатеричные коды цветов.
// Например:
// Шестнадцатеричный цвет определяется как: # RRGGBB, где RR (красный), GG (зеленый) и BB (синий) — шестнадцатеричные целые числа от 00 до FF , определяющие интенсивность цвета.
// Например, #FF0000 отображается красным цветом, потому что для красного компонента установлено максимальное значение (FF), а для остальных установлено значение 00.
// window.onload = function () {
//   var canvas = document.getElementById('canvas')
//   var context = canvas.getContext('2d')

//   context.rect(50, 50, 200, 150)

//   context.fillStyle = '#5e9860'
//   context.fill()

//   context.lineWidth = 10
//   context.strokeStyle = '#af1f1f'
//   context.stroke()
// }

// TODO: Styles (Стили)
// Те же функции fillStyle() и strokeStyle() можно использовать с кругами и другими фигурами.
// Сделаем в центре холста красный шар с серым контуром:
// window.onload = function () {
//   var canvas = document.getElementById('canvas')
//   var context = canvas.getContext('2d')

//   context.arc(300, 200, 100, 0, 2 * Math.PI)

//   context.fillStyle = '#de4646'
//   context.fill()

//   context.lineWidth = 6
//   context.strokeStyle = '#505050'
//   context.stroke()
// }

// TODO: Multiple Shapes (Несколько фигур)
// В случае, если нам нужно нарисовать несколько фигур, нам нужно использовать функцию beginPath() перед каждой фигурой. Например, нарисуем круг и прямоугольник:
// window.onload = function () {
//   var canvas = document.getElementById('canvas')
//   var context = canvas.getContext('2d')

//   context.beginPath()
//   context.rect(50, 50, 300, 200)
//   context.fillStyle = '#1775b7'
//   context.fill()

//   context.beginPath()
//   context.arc(300, 200, 100, 0, 2 * Math.PI)
//   context.fillStyle = '#de4646'
//   context.fill()
// }

//TODO: Drawing Text (Рисуем текст)
// Помимо фигур, вы также можете рисовать текст на холсте. Чтобы нарисовать простую строку текста, мы можем использовать функцию fillText ().
// Функция fillText () принимает в качестве параметров текст и начальные координаты.
// window.onload = function () {
//   var canvas = document.getElementById('canvas')
//   var context = canvas.getContext('2d')

//   context.fillText('Hello World', 200, 100)
// }

//TODO: Drawing Text (Рисуем текст)
// Мы можем установить размер и семейство шрифта, используя свойство font :
// Установка шрифта заставит контекст использовать его для всех операций рисования.
// window.onload = function () {
//   var canvas = document.getElementById('canvas')
//   var context = canvas.getContext('2d')

//   context.font = '42px Arial'
//   context.fillText('Hello World', 200, 100)
// }

// TODO: Drawing Text (Рисуем текст)
// Настройка цвета текста выполняется аналогично другим фигурам с помощью функции fillStyle() :
// window.onload = function () {
//   var canvas = document.getElementById('canvas')
//   var context = canvas.getContext('2d')

//   context.font = '42px Arial'
//   context.fillStyle = 'red'
//   context.fillText('Hello World', 200, 100)
// }

// TODO: Drawing Text (Рисуем текст)
// Вы также можете указать цвет и ширину контура, как и для других фигур, используя функцию strokeStyle() :
// Обратите внимание, что нам нужно вызвать функцию strokeText(), чтобы нарисовать контур.
// window.onload = function () {
//   var canvas = document.getElementById('canvas')
//   var context = canvas.getContext('2d')

//   context.font = '42px Arial'
//   context.fillStyle = 'red'
//   context.fillText('Hello World', 200, 100)
//   context.lineWidth = 2
//   context.strokeStyle = 'gray'
//   context.strokeText('Hello World', 200, 100)
// }

//TODO: Images (Картинки)
// Мы также можем добавлять изображения на холст.
// Для этого нам сначала нужно создать объект изображения в JavaScript и установить его исходный URL.
// В нашем примере мы будем использовать логотип Sololearn, расположенный на веб-сайте:
// В приведенном выше коде создается переменная с именем img, которая инициализируется изображением, а в качестве источника устанавливается URL-адрес.
// var img = new Image()
// img.src = 'https://blob.sololearn.com/avatars/sololearn.jpg'

//TODO: Images (Картинки)
// Функция drawImage () используется для рисования изображения на холсте.
// Он имеет следующий синтаксис:
// img — объект изображения, x и y — начальная позиция на холсте.
// ширина и высота являются необязательными параметрами и могут быть пропущены, по умолчанию используется исходный размер изображения.
// context.drawImage(img, x, y, width, height)

//TODO: Images (Картинки)
// Если мы вызовем функцию drawImage() после того, как создали объект изображения, изображение может не отображаться. Это происходит потому, что изображение еще не загружено.
// Чтобы избежать этой проблемы, обычно вызывают функцию drawImage() в событии загрузки изображения.
// Это нарисует изображение на холсте в позиции (50, 50) с размером 100x100.
// window.onload = function () {
//   var canvas = document.getElementById('canvas')
//   var context = canvas.getContext('2d')

//   var img = new Image()
//   img.src = 'https://blob.sololearn.com/avatars/sololearn.jpg'
//   img.onload = function () {
//     context.drawImage(img, 50, 50, 100, 100)
//   }
// }

//TODO: Images (Картинки)
// Мы можем нарисовать изображение любого размера, отличного от его исходного размера.
// Это может привести к масштабированию изображения, что может привести к нечетким или блочным артефактам из-за процесса масштабирования. Полотно автоматически использует алгоритмы сглаживания изображения при масштабировании изображений. Например, давайте нарисуем наше изображение очень большого размера:
// Вы можете отключить эту функцию, установив context.imageSmoothingEnabled = false;
// window.onload = function () {
//   var canvas = document.getElementById('canvas')
//   var context = canvas.getContext('2d')

//   var img = new Image()
//   img.src = 'https://blob.sololearn.com/avatars/sololearn.jpg'
//   img.onload = function () {
//     context.drawImage(img, -100, -100, 1024, 1024)
//   }
// }

//TODO: Animations (Анимации)
// Время анимировать!
// Мы знаем, как рисовать фигуры и текст на холсте, но как их перемещать?
// Холст — это доска для рисования, поэтому, когда мы что-то рисуем на нем, оно остается.
// Чтобы переместить объект, нам нужно очистить холст и перерисовать объект на новом месте.
// Это означает, что для создания анимации нам нужно постоянно рисовать на холсте, обновляя положение наших объектов.

//TODO: Animations (Анимации)
// Чтобы периодически вызывать наши инструкции по рисованию, мы можем использовать функцию setInterval() или setTimeout(), которые используются для вызова функции каждые x миллисекунд.
// Например, давайте создадим прямоугольник и переместим его горизонтально на нашем холсте.
// Во-первых, давайте создадим функцию draw(), которая будет рисовать прямоугольник в указанной позиции:
// Функция draw(), если она вызывается, нарисует квадрат размером 100x100 в позиции (x, y).
// var canvas = document.getElementById('canvas')
// var context = canvas.getContext('2d')
// var x = 0
// var y = 100

// function draw() {
//   context.beginPath()
//   context.rect(x, y, 100, 100)
//   context.fillStyle = 'red'
//   context.fill()
// }

//TODO: Animations (Анимации)
// Далее нам нужно увеличивать позицию x квадрата каждый раз, когда вызывается функция draw(). Мы добавляем 10 к x позиции квадрата. В случае, если x становится больше, чем ширина холста, нам нужно сбросить его положение до -100, чтобы анимация зациклилась и квадрат появился с левой стороны холста.
// Мы будем постоянно вызывать функцию draw(). Именно поэтому нам нужно добавить в него логику анимации.
// function draw() {
//   context.beginPath()
//   context.rect(x, y, 100, 100)
//   context.fillStyle = 'red'
//   context.fill()

//   x += 10
//   if (x >= 600) {
//     x = -100
//   }
// }

//TODO: Animations (Анимации)
// Теперь давайте будем вызывать функцию draw() с помощью setInterval() каждые 50 миллисекунд и посмотрим на результат:
// Квадрат начнет расширяться вправо.
// Но это не то, чего мы хотели. Это происходит потому, что мы не очистили холст, поэтому каждый раз, когда вызывается наша функция draw(), мы рисуем новый квадрат на старом холсте.
// Мы выбрали 50 миллисекунд для демонстрационных целей. Вы можете выбрать, когда перерисовывать холст, исходя из логики вашей анимации.
// setInterval(draw, 50)

//TODO: Animations (Анимации)
// Чтобы завершить нашу анимацию, нам нужно очищать холст каждый раз, когда мы рисуем новый квадрат.
// Это делается с помощью функции clearRect() :
// Функция clearRect () очищает указанную область холста. В нашем случае мы очистили весь холст.
// Запустите код, чтобы увидеть полученную анимацию!
// window.onload = function () {
//   var canvas = document.getElementById('canvas')
//   var context = canvas.getContext('2d')
//   var x = 0
//   var y = 100

//   function draw() {
//     context.clearRect(0, 0, 600, 400)

//     context.beginPath()
//     context.rect(x, y, 100, 100)
//     context.fillStyle = 'red'
//     context.fill()

//     x += 10
//     if (x >= 600) {
//       x = -100
//     }
//   }
//   setInterval(draw, 50)
// }

//TODO: Animations (Анимации)
// Поначалу это может показаться немного сложным, однако создавать анимацию легко, когда вы понимаете логику. Вот шаги для создания базовой анимации холста:
// 1. очистить холст.
// 2. Нарисуйте объекты в их новом положении.
// 3. обновить позиции на основе логики.
// 4. повторить процесс.
// Вот еще один пример простой анимации, в которой мяч подпрыгивает на месте:
// Откройте пример, чтобы увидеть весь код.
// В следующем модуле мы рассмотрим более продвинутые анимации, а также узнаем о частоте кадров и игровых циклах .
// Поэкспериментируйте с кодом, создайте собственную анимацию и поделитесь своими творениями в разделе комментариев!
// function draw() {
//   // ...

//   size += step
//   if (size >= 150 || size <= 50) {
//     step *= -1
//   }
// }

//TODO: Practice: Animations (Практика: Анимации)
// Повторяйте и практикуйте время!
// Чтобы завершить анимацию, нам нужно очищать холст каждый раз, когда мы рисуем объект с новыми координатами.
// Это делается с помощью функции clearRect():
// window.onload = function () {
//   var canvas = document.getElementById('canvas')
//   var context = canvas.getContext('2d')
//   var x = 0
//   var y = 100

//   function draw() {
//     context.clearRect(0, 0, 600, 400)

//     context.beginPath()
//     context.rect(x, y, 100, 100)
//     context.fillStyle = 'red'
//     context.fill()

//     x += 10
//     if (x >= 600) {
//       x = -100
//     }
//   }
//   setInterval(draw, 50)
// }

// TODO: Practice: Animation (Практика: Анимация)
// В этой части мы будем перемещать круг немного вверх каждый раз, когда нажимается кнопка «jump», а также отображать значение счетчика на холсте. Задачи:
// 1. В событии нажатия кнопки «jump» уменьшите положение круга по оси y на 25 (y -= 25)
// 2. В событии нажатия кнопки «jump» очистите холст и нарисуйте круг в новом месте.
// 3. Также нарисуйте значение переменной count белым текстом в позиции (20, 30).
// Обратите внимание, что вы должны повторить круг внутри функции on.click.
// window.onload = function () {
//   let btn = document.getElementById('jump')
//   let count = 0
//   var canvas = document.getElementById('canvas')
//   var context = canvas.getContext('2d')
//   var x = 300
//   var y = 350

//   context.arc(x, y, 50, 0, 2 * Math.PI)
//   context.fillStyle = 'red'
//   context.fill()

//   btn.onclick = function () {
//     count += 1
//     //changing the y position (изменение положения Y)
//     y -= 25
//     //clearing the canvas (очистка холста)
//     context.clearRect(0, 0, 600, 400)

//     //redrawing the circle (перерисовывание круга)
//     context.beginPath()
//     context.arc(x, y, 50, 0, 2 * Math.PI)
//     context.fillStyle = 'red'
//     context.fill()

//     //drawing the count value (рисование значения счета)
//     context.font = '25px Arial'
//     context.fillStyle = 'white'
//     context.fillText('Count: ' + count, 20, 30)
//   }
// }

//TODO: Game Loops (Игровые циклы)
// В предыдущем модуле мы узнали, как заставить объекты перемещаться по холсту: нам нужно непрерывно рисовать на холсте, каждый раз обновляя положение объекта. В разработке игр этот процесс называется игровым циклом. Игровой цикл содержит основную логику игры и обновляет игру. Он может отвечать за перемещение объектов, создание анимации, обработку пользовательского ввода и т.д.
// Цикл игры должен запускаться каждый раз, когда что-то происходит на game canvas.

//TODO: Game Loops (Игровые циклы)
// В нашем примере с анимацией мы создали функцию draw() и непрерывно вызывали ее с помощью функции setInterval() :
// Функция draw () вызывается каждые 50 миллисекунд.
// Это создает петлю, которая перемещает прямоугольник на холсте.
// window.onload = function () {
//   var canvas = document.getElementById('canvas')
//   var context = canvas.getContext('2d')
//   var x = 0
//   var y = 100

//   function draw() {
//     context.clearRect(0, 0, 600, 400)

//     context.beginPath()
//     context.rect(x, y, 100, 100)
//     context.fillStyle = 'red'
//     context.fill()

//     x += 10
//     if (x >= 600) {
//       x = -100
//     }
//   }
//   setInterval(draw, 50)
// }

//TODO: Game Loops (Игровые циклы)
// Однако запуск нашей функции draw() с setInterval() может привести к проблемам с производительностью. На более медленных устройствах браузер может не выполнять операции перерисовки в заданный период времени.
// Это в конечном итоге приведет к зависанию браузера и перестанет отвечать на запросы.

//TODO: Game Loops (Игровые циклы)
// JavaScript предоставляет функцию window.requestAnimationFrame(), которая сообщает браузеру, что вы хотите выполнить перерисовку. Мы можем использовать ее вместо функции setInterval (), чтобы браузер сам позаботился о периоде перерисовки, исходя из ресурсов устройства, на котором он запущен.
// Это означает, что использование window.requestAnimationFrame() не приведет к зависанию браузера и будет учитывать системные ресурсы при выполнении игрового цикла.

//TODO: Game Loops (Игровые циклы)
// Использовать window.requestAnimationFrame() очень просто.
// Нам просто нужно вызвать его в нашей функции draw() и предоставить ту же функцию рисования в качестве ее параметра.
// Это приведет к тому, что функция draw() будет вызываться в цикле:
// Чтобы запустить цикл, нам нужно вызвать функцию draw() при загрузке страницы.
// Запустите код, чтобы увидеть результат! Анимация будет более плавной, так как она будет корректироваться в зависимости от вашего устройства.
// window.onload = function () {
//   var canvas = document.getElementById('canvas')
//   var context = canvas.getContext('2d')
//   var x = 0
//   var y = 100

//   function draw() {
//     context.clearRect(0, 0, 600, 400)

//     context.beginPath()
//     context.rect(x, y, 100, 100)
//     context.fillStyle = 'red'
//     context.fill()

//     x += 10
//     if (x >= 600) {
//       x = -100
//     }
//     window.requestAnimationFrame(draw)
//   }
//   draw()
// }

//TODO: Frame Rate (Частота кадров)
// Пришло время узнать о некоторых ключевых концепциях, используемых в играх. Каждое обновление холста называется кадром. Частота перерисовок измеряется количеством frames per seconds (fps) (кадров в секунду). Это количество кадров, которые вы генерируете каждую секунду. В целом, вы получите более высокую частоту кадров на лучших устройствах, что приведет к более плавному игровому процессу. Вот почему профессиональные геймеры тратят много денег на лучшее оборудование, чтобы получить максимально возможный fps.
// Функция window.requestAnimationFrame() обычно работает со скоростью 60 кадров в секунду (fps).

//TODO: Frame Rate (Частота кадров)
// При использовании функции setInterval() для нашего цикла мы использовали для этого 50 миллисекунд. Получается 1000/50 = 20 кадров в секунду.
// Вы можете использовать меньшее число, чтобы получить более высокую частоту кадров. Например, давайте используем 16 мс, чтобы получить 60 кадров в секунду :
// Поиграйте со значением ms, чтобы увидеть разницу.
// window.onload = function () {
//   var canvas = document.getElementById('canvas')
//   var context = canvas.getContext('2d')
//   var x = 0
//   var y = 100

//   function draw() {
//     context.clearRect(0, 0, 600, 400)

//     context.beginPath()
//     context.rect(x, y, 100, 100)
//     context.fillStyle = 'red'
//     context.fill()

//     x += 10
//     if (x >= 600) {
//       x = -100
//     }
//   }
//   setInterval(draw, 16)
// }

//TODO: Frame Rate (Частота кадров)
// Но почему 60fps? Люди могут обрабатывать 10-12 кадров в секунду индивидуально. Все, что больше, будет восприниматься как движение, и именно поэтому движения кажутся более плавными. В фильмах обычно используется 24 кадра в секунду, но в большинстве игр частота кадров даже больше, обычно 60 кадров в секунду. Это число основано на частоте обновления большинства мониторов — 60 Гц. И именно поэтому функция window.requestAnimationFrame() работает со скоростью 60 кадров в секунду.
// Современные игры также работают со скоростью 120 кадров в секунду , учитывая, что дисплей поддерживает соответствующую частоту обновления.

//TODO: Frame Rate (Частота кадров)
// Давайте посчитаем и отобразим текущую частоту кадров в секунду, с которой работает наша анимация при использовании функции window.requestAnimationFrame(). Для этого нам сначала нужно рассчитать время, прошедшее между кадрами. Этого можно добиться, просто взяв текущее время и вычтя время предыдущего кадра, которое мы сохраним в переменной с именем t.
// Приведенный ниже код создает переменную t и обновляет ее значение до текущего времени во время каждой итерации.
// Обратите внимание, что мы использовали функцию JavaScript Date.now() , которая используется для получения текущего времени в миллисекундах.
// var t
// function draw() {
//   t = Date.now()
//   // ...
// }

//TODO: Frame Rate (Частота кадров)
// В настоящее время мы сохранили время для каждого кадра.
// Далее нам нужно рассчитать время, прошедшее между этими кадрами.
// Мы берем текущее значение Date.now() и вычитаем из него предыдущее значение t.
// Мы также делим число на 1000, чтобы получить секунды из миллисекунд.
// Результат показывает количество секунд, необходимое для создания одного кадра.
// Обратите внимание, что нам нужно рассчитать значение timePassed перед обновлением значения t.
// var t
// function draw() {
//   var timePassed = (Date.now() - t) / 1000
//   t = Date.now()
//   // ...
// }

//TODO: Frame Rate (Частота кадров)
// Теперь, когда у нас есть секунды, необходимые для создания одного кадра, нам просто нужно разделить 1 на это число, чтобы получить количество кадров в секунду:
// Функция Math.round() используется для округления результата до ближайшего целого числа.
// var fps = Math.round(1 / timePassed)

//TODO: Frame Rate (Частота кадров)
// Теперь нам нужно просто нарисовать значение fps на нашем холсте:
// Запустите код, чтобы увидеть частоту кадров, которую вы получаете на своем устройстве.
// window.onload = function () {
//   var canvas = document.getElementById('canvas')
//   var context = canvas.getContext('2d')
//   var x = 0
//   var y = 100

//   var t
//   function draw() {
//     var timePassed = (Date.now() - t) / 1000
//     t = Date.now()
//     var fps = Math.round(1 / timePassed)

//     context.clearRect(0, 0, 600, 400)

//     context.font = '25px Arial'
//     context.fillStyle = 'black'
//     context.fillText('FPS: ' + fps, 20, 30)

//     context.beginPath()
//     context.rect(x, y, 100, 100)
//     context.fillStyle = 'red'
//     context.fill()

//     x += 10
//     if (x >= 600) {
//       x = -100
//     }
//     window.requestAnimationFrame(draw)
//   }
//   draw()
// }

//TODO: Frame Rates (Частота кадров)
// Функция window.requestAnimationFrame() регулирует частоту кадров в зависимости от ресурсов устройства. Это означает, что вы можете получить разную частоту кадров на разных устройствах и даже на одном и том же устройстве, когда анимация включает несколько объектов и сложные вычисления. Это вызовет проблемы с игрой, потому что движение объектов не учитывает частоту кадров.
// Например, на более медленных устройствах с более низкой частотой кадров анимация будет выглядеть неряшливо, а на более высоких частотах кадров она будет супербыстрой.

//TODO: Frame Rates (Частота кадров)
// Нам нужно придумать решение для обработки динамической частоты кадров, чтобы анимация выглядела одинаково на всех устройствах.
// Для этого мы можем использовать время как фактор для нашей анимации и перемещать объект в зависимости от времени, прошедшего между кадрами. Таким образом, расстояние, пройденное нашим объектом за заданный период времени, всегда будет одинаковым, независимо от частоты кадров. Чтобы переместить объект относительно времени, нам сначала нужно определить значение скорости для нашего объекта. Допустим, мы хотим, чтобы он двигался со скоростью 100 пикселей в секунду:
// let speed = 100

//TODO: Frame Rates (Частота кадров)
// Помните, мы увеличивали позицию нашего прямоугольника на 10 в каждом кадре? Чтобы сделать это относительно времени, нам просто нужно изменить его, чтобы включить пройденные секунды и значение скорости:
// Это будет увеличивать позицию x нашего прямоугольника на пиксели скорости каждую секунду.
// Запустите код, чтобы увидеть результат. Вы также можете поиграть со значением скорости, чтобы увидеть разницу.
// window.onload = function () {
//   var canvas = document.getElementById('canvas')
//   var context = canvas.getContext('2d')
//   var x = 0
//   var y = 100

//   var t = Date.now()
//   let speed = 100

//   function draw() {
//     var timePassed = (Date.now() - t) / 1000
//     t = Date.now()
//     var fps = Math.round(1 / timePassed)

//     context.clearRect(0, 0, 600, 400)

//     context.font = '25px Arial'
//     context.fillStyle = 'black'
//     context.fillText('FPS: ' + fps, 20, 30)

//     context.beginPath()
//     context.rect(x, y, 100, 100)
//     context.fillStyle = 'red'
//     context.fill()

//     x += speed * timePassed

//     if (x >= 600) {
//       x = -100
//     }
//     window.requestAnimationFrame(draw)
//   }
//   draw()
// }

//TODO: Frame Rates (Частота кадров)
// Мы добились движения относительно времени! Если вы хотите перемещать объект на 100 пикселей каждую секунду, а ваша игра работает со скоростью 60 кадров в секунду, вы будете перемещать объект на 100/60 = 1,666 пикселей за кадр. Это то, что мы сделали в нашей функции draw(). Когда частота кадров увеличивается или уменьшается, скорость движения также будет меняться. Сколько бы времени ни прошло, ваши объекты всегда будут двигаться с заданной скоростью.
// Благодаря этому анимация работает одинаково на разных устройствах с разной частотой кадров.

//TODO: Collision Detection (Обнаружение столкновений)
// Еще одна важная концепция в играх — обнаружение столкновений.
// Это процесс понимания, когда объекты сталкиваются. Например, предположим, что мы хотим, чтобы наш прямоугольник останавливался, когда он достигает правой границы нашего холста. Прямо сейчас наш прямоугольник просто сбрасывает свою позицию, когда достигает конца холста. Это делается с помощью следующего кода:
// Как только положение прямоугольника превышает ширину холста, мы устанавливаем его на -100, что заставляет его начинать с самого начала.
// Мы используем -100 вместо 0, чтобы компенсировать ширину прямоугольника, которая равна 100.
// if (x >= 600) {
//   x = -100
// }

//TODO: Collision Detection (Обнаружение столкновений)
// Обнаружение столкновений выполняется аналогичным образом.
// Нам просто нужно сравнить положения объектов и проверить, пересекаются ли они. Чтобы понять, когда прямоугольник касается края холста, нам просто нужно сравнить его положение с положением края, которое соответствует ширине холста:
// if (x >= 600 - 100) {
//   speed = 0
// }
// Мы вычитаем 100 из ширины холста, потому что мы хотим, чтобы наш прямоугольник остановился, когда его правый край коснется границы (позиция вычисляется по левому краю, а ширина прямоугольника равна 100).
// Когда столкновение обнаружено, мы устанавливаем скорость на 0, чтобы остановить прямоугольник.

//TODO: Collision Detection (Обнаружение столкновений)
// Давайте сделаем это веселее и изменим направление прямоугольника, когда он касается края холста.
// Это означает, что когда прямоугольник достигает правого края, он начинает двигаться обратно влево, и наоборот. Для этого нам нужна переменная для определения направления движения:
// let dir = 1
// 1 укажет на положительное изменение координаты x, а -1 изменит его на противоположное.

//TODO: Collision Detection (Обнаружение столкновений)
// Далее нам нужно учитывать направление при перемещении прямоугольника:
// x += dir * (speed * timePassed)
// Когда dir равен 1, значение уравнения положительно, заставляя прямоугольник двигаться вправо.
// Когда dir равен -1, значение отрицательное, что уменьшает позицию x, заставляя ее двигаться влево.
// Это заставляет прямоугольник двигаться влево, когда dir равен 1, и вправо, когда он равен -1.

//TODO: Collision Detection (Обнаружение столкновений)
// Наконец, нам нужно изменить нашу логику обнаружения столкновений, чтобы включить левый край холста:
// || является логическим или оператором.
// Как только прямоугольник достигает любого из краев холста, направление его движения меняется на противоположное.
// Запустите код, чтобы увидеть, как прямоугольник отскакивает от краев холста.
// window.onload = function () {
//   var canvas = document.getElementById('canvas')
//   var context = canvas.getContext('2d')
//   var x = 0
//   var y = 100

//   var t = Date.now()
//   let speed = 300
//   let dir = 1

//   function draw() {
//     var timePassed = (Date.now() - t) / 1000
//     t = Date.now()
//     var fps = Math.round(1 / timePassed)

//     context.clearRect(0, 0, 600, 400)

//     context.font = '25px Arial'
//     context.fillStyle = 'black'
//     context.fillText('FPS: ' + fps, 20, 30)

//     context.beginPath()
//     context.rect(x, y, 100, 100)
//     context.fillStyle = 'red'
//     context.fill()

//     x += dir * (speed * timePassed)

//     if (x >= 600 - 100 || x <= 0) {
//       dir *= -1
//     }
//     window.requestAnimationFrame(draw)
//   }
//   draw()
// }

//TODO: Practice: Collision Detection (Практика: обнаружение столкновений)
// Прежде чем перейти к следующему захватывающему проекту, давайте повторим основные понятия из предыдущих двух уроков.
// 1. Функция window.requestAnimationFrame() регулирует частоту кадров в зависимости от ресурсов устройства.
// 2. Обнаружение столкновений — это процесс понимания того, когда объекты сталкиваются.
// Повторите этот код еще раз в качестве полного примера:
// window.onload = function () {
//   var canvas = document.getElementById('canvas')
//   var context = canvas.getContext('2d')
//   var x = 0
//   var y = 100

//   var t = Date.now()
//   let speed = 300
//   let dir = 1

//   function draw() {
//     var timePassed = (Date.now() - t) / 1000
//     t = Date.now()
//     var fps = Math.round(1 / timePassed)

//     context.clearRect(0, 0, 600, 400)

//     context.font = '25px Arial'
//     context.fillStyle = 'black'
//     context.fillText('FPS: ' + fps, 20, 30)

//     context.beginPath()
//     context.rect(x, y, 100, 100)
//     context.fillStyle = 'red'
//     context.fill()

//     x += dir * (speed * timePassed)

//     if (x >= 600 - 100 || x <= 0) {
//       dir *= -1
//     }
//     window.requestAnimationFrame(draw)
//   }
//   draw()
// }

//TODO: Practice: Game Loop (Практика: Игровые циклы)
// На этом этапе мы будем перерисовывать только при нажатии кнопки «jump».
// Настало время добавить реальный игровой цикл, чтобы мы могли добавить более сложные движения в будущих шагах.
// Задачи:
// 1. Создать функцию draw() и перенести в нее всю логику рисования.
// 2. Используйте функцию window.requestAnimationFrame(); вызывать его непрерывно как игровой цикл.
// 3. В этот момент событие щелчка кнопки перехода должно только увеличивать переменную count и изменять положение круга по оси y.
// 4. Вызовите функцию draw(), чтобы запустить игровой цикл.
// Функция draw () должна очищать холст. Нарисуйте текст и круг и вызовите функцию window.requestAnimationFrame(); функция.
// window.onload = function () {
//   let btn = document.getElementById('jump')
//   let count = 0
//   var canvas = document.getElementById('canvas')
//   var context = canvas.getContext('2d')
//   var x = 300
//   var y = 350

//   context.arc(x, y, 50, 0, 2 * Math.PI)
//   context.fillStyle = 'red'
//   context.fill()

//   btn.onclick = function () {
//     count += 1
//     //changing the y position (изменение положения Y)
//     y -= 25
//     //clearing the canvas (очистка холста)
//   }
//   function draw() {
//     //clearing the canvas (очистка холста)
//     context.clearRect(0, 0, 600, 400)

//     //redrawing the circle (перерисовывание круга)
//     context.beginPath()
//     context.arc(x, y, 50, 0, 2 * Math.PI)
//     context.fillStyle = 'red'
//     context.fill()

//     //drawing the count value (рисование значения счета)
//     context.font = '25px Arial'
//     context.fillStyle = 'white'
//     context.fillText('Count: ' + count, 20, 30)

//     window.requestAnimationFrame(draw)
//   }
//   draw()
// }

//TODO: User Input (Пользовательский ввод)
// И последнее, чему нам нужно научиться перед тем, как приступить к созданию реальной игры, — это обработка пользовательского ввода.
// Пользовательский ввод необходим для добавления контроля в нашу игру. Например, перемещайте объекты, когда пользователь нажимает клавиши, нажимает кнопки или объекты. Чтобы обработать пользовательский ввод, нам просто нужно обработать соответствующее событие и добавить логику в функцию-обработчик, аналогичную обработке нажатия кнопки.
// Для нашего примера давайте добавим элементы управления в нашу анимацию прямоугольника, чтобы пользователь мог перемещать прямоугольник в 4 направлениях (вверх, вниз, влево, вправо), нажимая соответствующие кнопки.

//TODO: User Input (Пользовательский ввод)
// Давайте сначала добавим кнопки в наш HTML:
// Мы добавили 4 кнопки с соответствующими идентификаторами, чтобы мы могли ссылаться на них в JavaScript.
// Мы также вложили кнопки в тег <div> , который действует как контейнер, выравнивая кнопки по центру экрана.
// Мы также использовали CSS, чтобы задать значения высоты и ширины для наших кнопок.
// Мы используем кнопки для наших элементов управления, чтобы их можно было использовать как на настольных компьютерах, так и на мобильных устройств.

//TODO: User Input (Пользовательский ввод)
// Теперь мы можем взять ссылку на кнопки в JavaScript. Давайте сделаем это только для правой кнопки, а затем повторим процесс для всех остальных кнопок.
// let right = document.getElementById('right')

//TODO: User Input (Пользовательский ввод)
// Пора заняться пресс-мероприятиями.
// При нажатии кнопки нам нужно переместить прямоугольник вправо.
// Когда кнопка не нажата, нам нужно остановить прямоугольник.
// Для этого определим переменную dir, которая будет указывать следующее:
// dir = 1 будет указывать на движение вправо;
// dir = 2: движение влево;
// dir = 3: движение вверх;
// dir = 4: движение вниз.
// дир = 0: стоп. Нам нужно установить соответствующее значение dir, когда кнопка нажата и отпущена:
// Мы использовали onmousedown и onmouseup для обработки событий нажатия и отпускания кнопки.
// right.onmousedown = function () {
//   dir = 1
// }
// right.onmouseup = function () {
//   dir = 0
// }

//TODO: User Input (Пользовательский ввод)
// События onmouseup и onmousedown используются, когда кнопка нажимается/отпускается с помощью мыши или аналогичного устройства ввода. Чтобы заставить его работать на сенсорных экранах, нам нужно обработать события ontouchstart и ontouchend:
// right.ontouchstart = function () {
//   dir = 1
// }
// right.ontouchend = function () {
//   dir = 0
// }

//TODO: User Input (Пользовательский ввод)
// В этот момент нажатие правой кнопки просто устанавливает значение переменной dir.
// Теперь нам нужно обработать значение dir и переместить прямоугольник.
// В нашей функции draw() нам нужно сделать следующее:
// Проверяем значение переменной dir и перемещаем прямоугольник в соответствующем направлении.
// if (dir == 1) {
//   x += speed * timePassed
// }

//TODO: User Input (Пользовательский ввод)
// Точно так же нам нужно обработать все остальные события нажатия/отпускания кнопки и переместить прямоугольник в соответствующем направлении:
// Обратите внимание, что мы меняем положение x прямоугольника для движения влево/вправо и положение y для движения вверх/вниз.
// Вот и все!
// window.onload = function () {
//   var canvas = document.getElementById('canvas')
//   var context = canvas.getContext('2d')
//   var x = 0
//   var y = 100

//   var t = Date.now()
//   let speed = 300
//   let dir = 0

//   let up = document.getElementById('up')
//   let down = document.getElementById('down')
//   let left = document.getElementById('left')
//   let right = document.getElementById('right')

//   up.onmousedown = function () {
//     dir = 4
//   }
//   down.onmousedown = function () {
//     dir = 3
//   }
//   left.onmousedown = function () {
//     dir = 2
//   }
//   right.onmousedown = function () {
//     dir = 1
//   }

//   up.ontouchstart = function () {
//     dir = 4
//   }
//   down.ontouchstart = function () {
//     dir = 3
//   }
//   left.ontouchstart = function () {
//     dir = 2
//   }
//   right.ontouchstart = function () {
//     dir = 1
//   }

//   up.onmouseup = function () {
//     dir = 0
//   }
//   down.onmouseup = function () {
//     dir = 0
//   }
//   left.onmouseup = function () {
//     dir = 0
//   }
//   right.onmouseup = function () {
//     dir = 0
//   }

//   up.ontouchend = function () {
//     dir = 0
//   }
//   down.ontouchend = function () {
//     dir = 0
//   }
//   left.ontouchend = function () {
//     dir = 0
//   }
//   right.ontouchend = function () {
//     dir = 0
//   }

//   function draw() {
//     var timePassed = (Date.now() - t) / 1000
//     t = Date.now()
//     var fps = Math.round(1 / timePassed)

//     context.clearRect(0, 0, 600, 400)

//     context.font = '25px Arial'
//     context.fillStyle = 'black'
//     context.fillText('FPS: ' + fps, 20, 30)

//     context.beginPath()
//     context.rect(x, y, 100, 100)
//     context.fillStyle = 'red'
//     context.fill()

//     if (dir == 1) {
//       x += speed * timePassed
//     } else if (dir == 2) {
//       x -= speed * timePassed
//     } else if (dir == 3) {
//       y += speed * timePassed
//     } else if (dir == 4) {
//       y -= speed * timePassed
//     }

//     window.requestAnimationFrame(draw)
//   }
//   draw()
// }

//TODO: User Input (Пользовательский ввод)
// Теперь все кнопки работают и двигают прямоугольник в соответствующем направлении.
// Однако прямоугольник может выходить за границы холста.
// Время для обнаружения столкновений!
// Как только прямоугольник достигнет конца холста, нам нужно его остановить. Мы можем сделать это, проверяя положение при перемещении блока и изменяя положение только тогда, когда прямоугольник находится в границах холста:
// Теперь мы можем управлять прямоугольником на холсте, и он остановится, когда соприкоснется с любой стороной холста.
// Обратите внимание, что нам нужно учитывать размер прямоугольника при проверке правого и нижнего положения, потому что положение x и y вычисляется из верхнего левого угла.
// window.onload = function () {
//   var canvas = document.getElementById('canvas')
//   var context = canvas.getContext('2d')
//   var x = 0
//   var y = 100

//   var t = Date.now()
//   let speed = 300
//   let dir = 0

//   let up = document.getElementById('up')
//   let down = document.getElementById('down')
//   let left = document.getElementById('left')
//   let right = document.getElementById('right')

//   up.onmousedown = function () {
//     dir = 4
//   }
//   down.onmousedown = function () {
//     dir = 3
//   }
//   left.onmousedown = function () {
//     dir = 2
//   }
//   right.onmousedown = function () {
//     dir = 1
//   }

//   up.ontouchstart = function () {
//     dir = 4
//   }
//   down.ontouchstart = function () {
//     dir = 3
//   }
//   left.ontouchstart = function () {
//     dir = 2
//   }
//   right.ontouchstart = function () {
//     dir = 1
//   }

//   up.onmouseup = function () {
//     dir = 0
//   }
//   down.onmouseup = function () {
//     dir = 0
//   }
//   left.onmouseup = function () {
//     dir = 0
//   }
//   right.onmouseup = function () {
//     dir = 0
//   }

//   up.ontouchend = function () {
//     dir = 0
//   }
//   down.ontouchend = function () {
//     dir = 0
//   }
//   left.ontouchend = function () {
//     dir = 0
//   }
//   right.ontouchend = function () {
//     dir = 0
//   }

//   function draw() {
//     var timePassed = (Date.now() - t) / 1000
//     t = Date.now()
//     var fps = Math.round(1 / timePassed)

//     context.clearRect(0, 0, 600, 400)

//     context.font = '25px Arial'
//     context.fillStyle = 'black'
//     context.fillText('FPS: ' + fps, 20, 30)

//     context.beginPath()
//     context.rect(x, y, 100, 100)
//     context.fillStyle = 'red'
//     context.fill()

//     if (dir == 1) {
//       if (x + 100 < 600) {
//         x += speed * timePassed
//       }
//     } else if (dir == 2) {
//       if (x > 0) {
//         x -= speed * timePassed
//       }
//     } else if (dir == 3) {
//       if (y + 100 < 400) {
//         y += speed * timePassed
//       }
//     } else if (dir == 4) {
//       if (y > 0) {
//         y -= speed * timePassed
//       }
//     }

//     window.requestAnimationFrame(draw)
//   }
//   draw()
// }

//TODO: Practice: User Input (Практика: пользовательский ввод)
// Реализуем функциональность пользовательского ввода в вашем проекте!
// Вот события, которые вы будете использовать:
// 1. onkeydown используется при нажатии любой клавиши на клавиатуре.
// 2. Ontouchstart используется при касании экрана на мобильном устройстве.

//TODO: Practice: User Input (Практика: пользовательский ввод)
// Как закодировано прямо сейчас, наш круг движется вверх только при нажатии кнопки jump.
// Мы хотим изменить его так, чтобы он двигался при нажатии любой клавиши на клавиатуре или при касании экрана на мобильном устройстве.
// Задачи:
// 1. Обработать события onkeydown и ontouchstart, добавив ту же логику, что и с кнопкой Jump.
// 2. Удалите кнопку Jump и ее обработчик кликов со страницы.
// Подсказка : вот как вы должны обрабатывать события:
// Теперь, когда вы касаетесь экрана или нажимаете любую клавишу, круг должен двигаться вверх, а счетчик должен обновляться.
// window.onload = function () {
//   let btn = document.getElementById('jump')
//   let count = 0
//   var canvas = document.getElementById('canvas')
//   var context = canvas.getContext('2d')
//   var x = 300
//   var y = 350

//   context.arc(x, y, 50, 0, 2 * Math.PI)
//   context.fillStyle = 'red'
//   context.fill()

//   document.onkeydown = function () {
//     count += 1
//     y -= 25
//   }
//   document.ontouchstart = function () {
//     count += 1
//     y -= 25
//   }

//   function draw() {
//     //clearing the canvas (очистка холста)
//     context.clearRect(0, 0, 600, 400)

//     //redrawing the circle (перерисовывание круга)
//     context.beginPath()
//     context.arc(x, y, 50, 0, 2 * Math.PI)
//     context.fillStyle = 'red'
//     context.fill()

//     //drawing the count value (рисование значения счета)
//     context.font = '25px Arial'
//     context.fillStyle = 'white'
//     context.fillText('Count: ' + count, 20, 30)

//     window.requestAnimationFrame(draw)
//   }
//   draw()
// }

//TODO: Making a Game (Создание игры)
// На данный момент мы знаем, как перемещать объекты, управлять ими с помощью пользовательского ввода и обнаруживать столкновения.
// Итак, теперь мы можем сделать настоящую игру! Во время этого урока мы продолжим работу над кодом, который мы создали, и сделаем его игрой по сбору монет, в которой пользователь должен собирать монеты, которые появляются на холсте, и зарабатывать очки.
// Оставайтесь с нами, будет весело!

//TODO: Coin Collector (Коллекционер монет)
// Во-первых, давайте изменим начальную позицию нашего красного прямоугольника, соответствующего игроку, установив его в центре холста:
// Мы устанавливаем начальное положение прямоугольника в (250, 150), что поместит его в центр холста (600x400), потому что прямоугольник имеет ширину и высоту 100.
// (600-100)/2 = 250
// (400-100)/2 = 150
// window.onload = function () {
//   var canvas = document.getElementById('canvas')
//   var context = canvas.getContext('2d')
//   var x = 250
//   var y = 150

//   var t = Date.now()
//   let speed = 300
//   let dir = 0

//   let up = document.getElementById('up')
//   let down = document.getElementById('down')
//   let left = document.getElementById('left')
//   let right = document.getElementById('right')

//   up.onmousedown = function () {
//     dir = 4
//   }
//   down.onmousedown = function () {
//     dir = 3
//   }
//   left.onmousedown = function () {
//     dir = 2
//   }
//   right.onmousedown = function () {
//     dir = 1
//   }

//   up.ontouchstart = function () {
//     dir = 4
//   }
//   down.ontouchstart = function () {
//     dir = 3
//   }
//   left.ontouchstart = function () {
//     dir = 2
//   }
//   right.ontouchstart = function () {
//     dir = 1
//   }

//   up.onmouseup = function () {
//     dir = 0
//   }
//   down.onmouseup = function () {
//     dir = 0
//   }
//   left.onmouseup = function () {
//     dir = 0
//   }
//   right.onmouseup = function () {
//     dir = 0
//   }

//   up.ontouchend = function () {
//     dir = 0
//   }
//   down.ontouchend = function () {
//     dir = 0
//   }
//   left.ontouchend = function () {
//     dir = 0
//   }
//   right.ontouchend = function () {
//     dir = 0
//   }

//   function draw() {
//     var timePassed = (Date.now() - t) / 1000
//     t = Date.now()
//     var fps = Math.round(1 / timePassed)

//     context.clearRect(0, 0, 600, 400)

//     context.font = '25px Arial'
//     context.fillStyle = 'black'
//     context.fillText('FPS: ' + fps, 20, 30)

//     context.beginPath()
//     context.rect(x, y, 100, 100)
//     context.fillStyle = 'red'
//     context.fill()

//     if (dir == 1) {
//       if (x + 100 < 600) {
//         x += speed * timePassed
//       }
//     } else if (dir == 2) {
//       if (x > 0) {
//         x -= speed * timePassed
//       }
//     } else if (dir == 3) {
//       if (y + 100 < 400) {
//         y += speed * timePassed
//       }
//     } else if (dir == 4) {
//       if (y > 0) {
//         y -= speed * timePassed
//       }
//     }

//     window.requestAnimationFrame(draw)
//   }
//   draw()
// }

//TODO: Coin Collector (Коллекционер монет)
// Давайте нарисуем монеты!
// Монета будет представлена ​​желтым прямоугольником размером 50x50.
// Как и в случае с нашим красным прямоугольником, нам нужны переменные для хранения положения монеты:
// var coinx = Math.random() * (600 - 50)
// var coiny = Math.random() * (400 - 50)
// Мы используем функцию Math.random() для генерации случайного положения монеты на холсте.
// Math.random() генерирует случайное число в диапазоне [0-1).

//TODO: Coin Collector (Коллекционер монет)
// Теперь мы можем нарисовать монету на нашем холсте:
// При каждом запуске кода желтый прямоугольник рисуется в случайном месте.
// window.onload = function () {
//   var canvas = document.getElementById('canvas')
//   var context = canvas.getContext('2d')
//   var x = 250
//   var y = 150
//   var coinx = Math.random() * (600 - 50)
//   var coiny = Math.random() * (400 - 50)

//   var t = Date.now()
//   let speed = 300
//   let dir = 0

//   let up = document.getElementById('up')
//   let down = document.getElementById('down')
//   let left = document.getElementById('left')
//   let right = document.getElementById('right')

//   up.onmousedown = function () {
//     dir = 4
//   }
//   down.onmousedown = function () {
//     dir = 3
//   }
//   left.onmousedown = function () {
//     dir = 2
//   }
//   right.onmousedown = function () {
//     dir = 1
//   }

//   up.ontouchstart = function () {
//     dir = 4
//   }
//   down.ontouchstart = function () {
//     dir = 3
//   }
//   left.ontouchstart = function () {
//     dir = 2
//   }
//   right.ontouchstart = function () {
//     dir = 1
//   }

//   up.onmouseup = function () {
//     dir = 0
//   }
//   down.onmouseup = function () {
//     dir = 0
//   }
//   left.onmouseup = function () {
//     dir = 0
//   }
//   right.onmouseup = function () {
//     dir = 0
//   }

//   up.ontouchend = function () {
//     dir = 0
//   }
//   down.ontouchend = function () {
//     dir = 0
//   }
//   left.ontouchend = function () {
//     dir = 0
//   }
//   right.ontouchend = function () {
//     dir = 0
//   }

//   function draw() {
//     var timePassed = (Date.now() - t) / 1000
//     t = Date.now()
//     var fps = Math.round(1 / timePassed)

//     context.clearRect(0, 0, 600, 400)

//     context.font = '25px Arial'
//     context.fillStyle = 'black'
//     context.fillText('FPS: ' + fps, 20, 30)

//     context.beginPath()
//     context.rect(x, y, 100, 100)
//     context.fillStyle = 'red'
//     context.fill()

//     context.beginPath()
//     context.rect(coinx, coiny, 50, 50)
//     context.fillStyle = '#e3c228'
//     context.fill()

//     if (dir == 1) {
//       if (x + 100 < 600) {
//         x += speed * timePassed
//       }
//     } else if (dir == 2) {
//       if (x > 0) {
//         x -= speed * timePassed
//       }
//     } else if (dir == 3) {
//       if (y + 100 < 400) {
//         y += speed * timePassed
//       }
//     } else if (dir == 4) {
//       if (y > 0) {
//         y -= speed * timePassed
//       }
//     }

//     window.requestAnimationFrame(draw)
//   }
//   draw()
// }

//TODO: Coin Collector (Коллекционер монет)
// Следующий шаг — добавить в игру счет и увеличивать его каждый раз, когда игрок собирает монету.
// Логика обнаружения столкновений может показаться немного сложной, но она просто сравнивает координаты x и y прямоугольников с учетом их размеров.
// При обнаружении столкновения счет увеличивается, а положение монеты сбрасывается до нового случайного значения.
// Запустите код и соберите монеты, чтобы увидеть логику в действии!
// window.onload = function () {
//   var canvas = document.getElementById('canvas')
//   var context = canvas.getContext('2d')
//   var x = 250
//   var y = 150
//   var coinx = Math.random() * (600 - 50)
//   var coiny = Math.random() * (400 - 50)

//   var t = Date.now()
//   let speed = 300
//   let dir = 0
//   let score = 0

//   let up = document.getElementById('up')
//   let down = document.getElementById('down')
//   let left = document.getElementById('left')
//   let right = document.getElementById('right')

//   up.onmousedown = function () {
//     dir = 4
//   }
//   down.onmousedown = function () {
//     dir = 3
//   }
//   left.onmousedown = function () {
//     dir = 2
//   }
//   right.onmousedown = function () {
//     dir = 1
//   }

//   up.ontouchstart = function () {
//     dir = 4
//   }
//   down.ontouchstart = function () {
//     dir = 3
//   }
//   left.ontouchstart = function () {
//     dir = 2
//   }
//   right.ontouchstart = function () {
//     dir = 1
//   }

//   up.onmouseup = function () {
//     dir = 0
//   }
//   down.onmouseup = function () {
//     dir = 0
//   }
//   left.onmouseup = function () {
//     dir = 0
//   }
//   right.onmouseup = function () {
//     dir = 0
//   }

//   up.ontouchend = function () {
//     dir = 0
//   }
//   down.ontouchend = function () {
//     dir = 0
//   }
//   left.ontouchend = function () {
//     dir = 0
//   }
//   right.ontouchend = function () {
//     dir = 0
//   }

//   function draw() {
//     var timePassed = (Date.now() - t) / 1000
//     t = Date.now()
//     var fps = Math.round(1 / timePassed)

//     context.clearRect(0, 0, 600, 400)

//     context.font = '25px Arial'
//     context.fillStyle = 'black'
//     context.fillText('FPS: ' + fps, 20, 30)

//     context.beginPath()
//     context.rect(x, y, 100, 100)
//     context.fillStyle = 'red'
//     context.fill()

//     context.beginPath()
//     context.rect(coinx, coiny, 50, 50)
//     context.fillStyle = '#e3c228'
//     context.fill()

//     if (dir == 1) {
//       if (x + 100 < 600) {
//         x += speed * timePassed
//       }
//     } else if (dir == 2) {
//       if (x > 0) {
//         x -= speed * timePassed
//       }
//     } else if (dir == 3) {
//       if (y + 100 < 400) {
//         y += speed * timePassed
//       }
//     } else if (dir == 4) {
//       if (y > 0) {
//         y -= speed * timePassed
//       }
//     }

//     if (
//       coinx <= x + 100 &&
//       x <= coinx + 50 &&
//       coiny <= y + 100 &&
//       y <= coiny + 50
//     ) {
//       score++
//       coinx = Math.random() * (600 - 50)
//       coiny = Math.random() * (400 - 50)
//     }

//     window.requestAnimationFrame(draw)
//   }
//   draw()
// }

//TODO: Coin Collector (Коллекционер монет)
// В качестве завершающего шага вместо значения FPS покажем текущий счет:
// Это делает полнофункциональную игру, в которой вы собираете монеты и увеличиваете свой счет.
// Запустите код, чтобы проверить это!
// window.onload = function () {
//   var canvas = document.getElementById('canvas')
//   var context = canvas.getContext('2d')
//   var x = 250
//   var y = 150
//   var coinx = Math.random() * (600 - 50)
//   var coiny = Math.random() * (400 - 50)

//   var t = Date.now()
//   let speed = 300
//   let dir = 0
//   let score = 0

//   let up = document.getElementById('up')
//   let down = document.getElementById('down')
//   let left = document.getElementById('left')
//   let right = document.getElementById('right')

//   up.onmousedown = function () {
//     dir = 4
//   }
//   down.onmousedown = function () {
//     dir = 3
//   }
//   left.onmousedown = function () {
//     dir = 2
//   }
//   right.onmousedown = function () {
//     dir = 1
//   }

//   up.ontouchstart = function () {
//     dir = 4
//   }
//   down.ontouchstart = function () {
//     dir = 3
//   }
//   left.ontouchstart = function () {
//     dir = 2
//   }
//   right.ontouchstart = function () {
//     dir = 1
//   }

//   up.onmouseup = function () {
//     dir = 0
//   }
//   down.onmouseup = function () {
//     dir = 0
//   }
//   left.onmouseup = function () {
//     dir = 0
//   }
//   right.onmouseup = function () {
//     dir = 0
//   }

//   up.ontouchend = function () {
//     dir = 0
//   }
//   down.ontouchend = function () {
//     dir = 0
//   }
//   left.ontouchend = function () {
//     dir = 0
//   }
//   right.ontouchend = function () {
//     dir = 0
//   }

//   function draw() {
//     var timePassed = (Date.now() - t) / 1000
//     t = Date.now()

//     context.clearRect(0, 0, 600, 400)

//     context.font = '25px Arial'
//     context.fillStyle = 'black'
//     context.fillText('Score: ' + score, 20, 30)

//     context.beginPath()
//     context.rect(x, y, 100, 100)
//     context.fillStyle = 'red'
//     context.fill()

//     context.beginPath()
//     context.rect(coinx, coiny, 50, 50)
//     context.fillStyle = '#e3c228'
//     context.fill()

//     if (dir == 1) {
//       if (x + 100 < 600) {
//         x += speed * timePassed
//       }
//     } else if (dir == 2) {
//       if (x > 0) {
//         x -= speed * timePassed
//       }
//     } else if (dir == 3) {
//       if (y + 100 < 400) {
//         y += speed * timePassed
//       }
//     } else if (dir == 4) {
//       if (y > 0) {
//         y -= speed * timePassed
//       }
//     }

//     if (
//       coinx <= x + 100 &&
//       x <= coinx + 50 &&
//       coiny <= y + 100 &&
//       y <= coiny + 50
//     ) {
//       score++
//       coinx = Math.random() * (600 - 50)
//       coiny = Math.random() * (400 - 50)
//     }

//     window.requestAnimationFrame(draw)
//   }
//   draw()
// }

//TODO: Summary (Резюме)
// Коллекционер монет — это очень простая игра, демонстрирующая, как создавать игры в Интернете.
// Мы использовали пользовательский ввод для управления игроком, обнаруживали столкновения, используя простое сравнение позиций, и подсчитывали очки игрока.
// Этот процесс можно использовать для создания любой сложной игры в Интернете! Настройте игру, добавив изображения, фоны и более сложную игровую логику.
// Поделитесь своими творениями с сообществом в разделе комментариев!

//TODO: Practice: The Final Stage (Практика: Заключительный этап)
// Вы проделали потрясающую работу! Вы находитесь на завершающей стадии вашего проекта.
// И последнее, на что стоит обратить внимание — метод Date.now() .
// Он возвращает количество миллисекунд, прошедших с 1 января 1970 года. Например, этот код вернет количество лет, прошедших с 1970 года:
// calculate milliseconds in a year
// let minute = 1000 * 60
// let hour = minute * 60
// let day = hour * 24
// let year = day * 365

// // divide Date.now() with a year
// let years = Math.round(Date.now() / year)
// console.log(years)

//TODO: Practice: Adding Gravity (Практика: Добавление гравитации)
// Время доработать наш проект и превратить его в игру!
// Теперь давайте добавим к мячу гравитацию, чтобы он падал в воздухе, и сбросим счет, когда он коснется земли.
// Задания:
// 1. Сначала совершить движения относительно времени. Для этого добавьте переменную t и инициализируйте ее текущим временем с помощью Date.now().
// 2. Далее добавляем переменную скорости и инициализируем ее значением 25.
// 3. В функции draw () вычисляем разницу во времени между кадрами в переменной timePassed и устанавливаем переменную t на текущее время.
// var timePassed = (Date.now() - t) / 1000
// t = Date.now()
// 4. Чтобы добавить эффект гравитации, нам нужно увеличить скорость при падении мяча.
// Используйте следующий код:
// if (y <= 350) {
//   speed += 50 * timePassed
//   y += speed * timePassed
// }
// Это увеличит скорость мяча и сместит его вниз с этой скоростью.
// 5. Когда мяч подпрыгнет, сбросьте скорость до 25. Добавьте скорость=25 в обработчики событий.
// 6. Сбросить счет, когда мяч коснется земли:
// if (y > 350) {
//   count = 0
// }
// Поздравляем, у вас есть полнофункциональная игра! Поэкспериментируйте со скоростью падения и гравитацией, добавьте более сложную логику, настройте свою игру и поделитесь своим творением с сообществом!
window.onload = function () {
  let btn = document.getElementById('jump')
  let count = 0
  var canvas = document.getElementById('canvas')
  var context = canvas.getContext('2d')
  var x = 300
  var y = 350

  var t = Date.now()
  let speed = 25

  context.fillStyle = 'red'
  context.fill()

  document.onkeydown = function () {
    count += 1
    y -= 25
  }
  document.ontouchstart = function () {
    count += 1
    y -= 25
  }

  function draw() {
    var timePassed = (Date.now() - t) / 1000
    t = Date.now()

    //clearing the canvas (очистка холста)
    context.clearRect(0, 0, 600, 400)

    //redrawing the circle (перерисовывание круга)
    context.beginPath()
    context.arc(x, y, 50, 0, 2 * Math.PI)
    context.fillStyle = 'red'
    context.fill()

    //drawing the count value (рисование значения счета)
    context.font = '25px Arial'
    context.fillStyle = 'white'
    context.fillText('Count: ' + count, 20, 30)

    if (y <= 350) {
      speed += 50 * timePassed
      y += speed * timePassed
      speed = 25
    }
    if (y > 350) {
      count = 0
    }

    window.requestAnimationFrame(draw)
  }
  draw()
}
